<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Assimp: Assimp::AMFImporter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Assimp
   &#160;<span id="projectnumber">5.0.1, master @ cd42b955</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_assimp.html">Assimp</a></li><li class="navelem"><a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_assimp_1_1_a_m_f_importer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Assimp::AMFImporter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that holding scene graph which include: geometry, metadata, materials etc.  
 <a href="class_assimp_1_1_a_m_f_importer.html#details">More...</a></p>

<p>Inherits <a class="el" href="class_assimp_1_1_base_importer.html">Assimp::BaseImporter</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html">SComplexFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for post-processing step. Contain face data.  <a href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___composite.html">SPP_Composite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for post-processing step. More suitable container for part of material's composition.  <a href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___composite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for post-processing step.  <a href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___texture.html">SPP_Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for post-processing step. More suitable container for texture.  <a href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6b225ea9aa92433ec03cb41492a0d451"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a> { <br />
&#160;&#160;<a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451af84e338c6e9a678ed63b8b2b7de9ef02">M</a>
, <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451a1633eb908b6889de4de75080bbf13229">MM</a>
, <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451af5fe8cb0ad373c368ac0d87e9141a833">CM</a>
, <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451ace3a659f5caad10cf4ac6f2de87d35c3">INCHES</a>
, <br />
&#160;&#160;<a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451ae90aa4e961f527f988365ee77d476118">FEET</a>
<br />
 }</td></tr>
<tr class="separator:a6b225ea9aa92433ec03cb41492a0d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe6b47937a7c897536cac1513b65eb7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7">TextFileMode</a> { <a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7af10ad62259d2e54eff440019b345e309">ALLOW_EMPTY</a>
, <a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7ae507341521279743797bdce9f7a21081">FORBID_EMPTY</a>
 }</td></tr>
<tr class="memdesc:a9fe6b47937a7c897536cac1513b65eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to define, if empty files are ok or not.  <a href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7">More...</a><br /></td></tr>
<tr class="separator:a9fe6b47937a7c897536cac1513b65eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a773ef728497dcfd14ae4df39304d3b3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a773ef728497dcfd14ae4df39304d3b3e">AMFImporter</a> () <a class="el" href="defs_8h.html#ae032f18edd69bf6ba935ef9feb025a96">AI_NO_EXCEPT</a></td></tr>
<tr class="memdesc:a773ef728497dcfd14ae4df39304d3b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_assimp_1_1_a_m_f_importer.html#a773ef728497dcfd14ae4df39304d3b3e">More...</a><br /></td></tr>
<tr class="separator:a773ef728497dcfd14ae4df39304d3b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029ced8aacd6661286e747d9f6c08fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a7029ced8aacd6661286e747d9f6c08fd">AMFImporter</a> (const <a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a> &amp;pScene)=delete</td></tr>
<tr class="separator:a7029ced8aacd6661286e747d9f6c08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f9a71e68764d6e3d5b151173cda420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ae7f9a71e68764d6e3d5b151173cda420">~AMFImporter</a> ()</td></tr>
<tr class="memdesc:ae7f9a71e68764d6e3d5b151173cda420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="class_assimp_1_1_a_m_f_importer.html#ae7f9a71e68764d6e3d5b151173cda420">More...</a><br /></td></tr>
<tr class="separator:ae7f9a71e68764d6e3d5b151173cda420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a2e04a7d988def5ddc00c2f65532f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a85a2e04a7d988def5ddc00c2f65532f7">CanRead</a> (const std::string &amp;pFile, <a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler, bool pCheckSig) const</td></tr>
<tr class="memdesc:a85a2e04a7d988def5ddc00c2f65532f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the class can handle the format of the given file.  <a href="class_assimp_1_1_a_m_f_importer.html#a85a2e04a7d988def5ddc00c2f65532f7">More...</a><br /></td></tr>
<tr class="separator:a85a2e04a7d988def5ddc00c2f65532f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f50ef50c8ce066cfa9c1034c2161948"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4f50ef50c8ce066cfa9c1034c2161948">Find_ConvertedMaterial</a> (const std::string &amp;pID, const <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a> **pConvertedMaterial) const</td></tr>
<tr class="separator:a4f50ef50c8ce066cfa9c1034c2161948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fa072ffa46e867e23db2a9e2160daf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#af0fa072ffa46e867e23db2a9e2160daf">Find_ConvertedNode</a> (const std::string &amp;pID, <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">NodeArray</a> &amp;nodeArray, <a class="el" href="structai_node.html">aiNode</a> **pNode) const</td></tr>
<tr class="separator:af0fa072ffa46e867e23db2a9e2160daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38726efa592db2c8fdc51f7b2cfd1bf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a38726efa592db2c8fdc51f7b2cfd1bf0">Find_NodeElement</a> (const std::string &amp;pID, const <a class="el" href="class_a_m_f_node_element_base.html#a8461de95fe616786ef54db126007eb0a">AMFNodeElementBase::EType</a> pType, <a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> **pNodeElement) const</td></tr>
<tr class="separator:a38726efa592db2c8fdc51f7b2cfd1bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51876206d286fb5804a2e99ad1fcae12"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a51876206d286fb5804a2e99ad1fcae12">GetApplicationUnits</a> ()</td></tr>
<tr class="separator:a51876206d286fb5804a2e99ad1fcae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c379ec3a8399551d7b379de7fc3bc1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a15c379ec3a8399551d7b379de7fc3bc1">GetErrorText</a> () const</td></tr>
<tr class="memdesc:a15c379ec3a8399551d7b379de7fc3bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error description of the last error that occurred.  <a href="class_assimp_1_1_base_importer.html#a15c379ec3a8399551d7b379de7fc3bc1">More...</a><br /></td></tr>
<tr class="separator:a15c379ec3a8399551d7b379de7fc3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9397b157ff1b56d7d360a39ca41ac"><td class="memItemLeft" align="right" valign="top">const std::exception_ptr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a05f9397b157ff1b56d7d360a39ca41ac">GetException</a> () const</td></tr>
<tr class="memdesc:a05f9397b157ff1b56d7d360a39ca41ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exception of the last exception that occurred.  <a href="class_assimp_1_1_base_importer.html#a05f9397b157ff1b56d7d360a39ca41ac">More...</a><br /></td></tr>
<tr class="separator:a05f9397b157ff1b56d7d360a39ca41ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925321c2c2fe2702854c1b1b86ad6639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a925321c2c2fe2702854c1b1b86ad6639">GetExtensionList</a> (std::set&lt; std::string &gt; &amp;pExtensionList)</td></tr>
<tr class="separator:a925321c2c2fe2702854c1b1b86ad6639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e52bc7b3d7833000737018a8301efc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a21e52bc7b3d7833000737018a8301efc">GetFileScale</a> () const</td></tr>
<tr class="separator:a21e52bc7b3d7833000737018a8301efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e10b5a345ab82b1f740e3a6f0ed575"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a11e10b5a345ab82b1f740e3a6f0ed575">GetInfo</a> () const</td></tr>
<tr class="memdesc:a11e10b5a345ab82b1f740e3a6f0ed575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by #Importer::GetImporterInfo to get a description of some loader features.  <a href="class_assimp_1_1_a_m_f_importer.html#a11e10b5a345ab82b1f740e3a6f0ed575">More...</a><br /></td></tr>
<tr class="separator:a11e10b5a345ab82b1f740e3a6f0ed575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0559661295085fc31d3c2b9f6a3eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a3c0559661295085fc31d3c2b9f6a3eb9">InternReadFile</a> (const std::string &amp;pFile, <a class="el" href="structai_scene.html">aiScene</a> *pScene, <a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler)</td></tr>
<tr class="memdesc:a3c0559661295085fc31d3c2b9f6a3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the given file into the given scene structure.  <a href="class_assimp_1_1_a_m_f_importer.html#a3c0559661295085fc31d3c2b9f6a3eb9">More...</a><br /></td></tr>
<tr class="separator:a3c0559661295085fc31d3c2b9f6a3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2110829b40afb0f82039289217879c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#af2110829b40afb0f82039289217879c1">operator=</a> (const <a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a> &amp;pScene)=delete</td></tr>
<tr class="separator:af2110829b40afb0f82039289217879c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f19d53310ef5b54f5bdce46bbd098f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ae2f19d53310ef5b54f5bdce46bbd098f">ParseFile</a> (const std::string &amp;pFile, <a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler)</td></tr>
<tr class="memdesc:ae2f19d53310ef5b54f5bdce46bbd098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse AMF file and fill scene graph.  <a href="class_assimp_1_1_a_m_f_importer.html#ae2f19d53310ef5b54f5bdce46bbd098f">More...</a><br /></td></tr>
<tr class="separator:ae2f19d53310ef5b54f5bdce46bbd098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3082a3a110c6cf65d3c74b1977c037d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a3082a3a110c6cf65d3c74b1977c037d5">ParseHelper_FixTruncatedFloatString</a> (const char *pInStr, std::string &amp;pOutString)</td></tr>
<tr class="separator:a3082a3a110c6cf65d3c74b1977c037d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c14cbd0ddc699098a71e320588ae361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a0c14cbd0ddc699098a71e320588ae361">ParseHelper_Node_Enter</a> (<a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> *child)</td></tr>
<tr class="separator:a0c14cbd0ddc699098a71e320588ae361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297134f091bc15389459fe2bb31d46aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a297134f091bc15389459fe2bb31d46aa">ParseHelper_Node_Exit</a> ()</td></tr>
<tr class="separator:a297134f091bc15389459fe2bb31d46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f06945fa656ebedde67819945b28c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a047f06945fa656ebedde67819945b28c">ReadFile</a> (<a class="el" href="class_assimp_1_1_importer.html">Importer</a> *pImp, const std::string &amp;pFile, <a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler)</td></tr>
<tr class="memdesc:a047f06945fa656ebedde67819945b28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the given file and returns the imported data.  <a href="class_assimp_1_1_base_importer.html#a047f06945fa656ebedde67819945b28c">More...</a><br /></td></tr>
<tr class="separator:a047f06945fa656ebedde67819945b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e10c82316e3afd685732e8f734f87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a9c5e10c82316e3afd685732e8f734f87">SetApplicationUnits</a> (const <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a> &amp;unit)</td></tr>
<tr class="separator:a9c5e10c82316e3afd685732e8f734f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf1d4f1475e98f96f95fa46aad44c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a8faf1d4f1475e98f96f95fa46aad44c1">SetFileScale</a> (double scale)</td></tr>
<tr class="memdesc:a8faf1d4f1475e98f96f95fa46aad44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will be called only by scale process when scaling is requested.  <a href="class_assimp_1_1_base_importer.html#a8faf1d4f1475e98f96f95fa46aad44c1">More...</a><br /></td></tr>
<tr class="separator:a8faf1d4f1475e98f96f95fa46aad44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecaa6b808b2b282cb6aa321970a2ad3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a2ecaa6b808b2b282cb6aa321970a2ad3">SetupProperties</a> (const <a class="el" href="class_assimp_1_1_importer.html">Importer</a> *pImp)</td></tr>
<tr class="memdesc:a2ecaa6b808b2b282cb6aa321970a2ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called prior to <a class="el" href="class_assimp_1_1_base_importer.html#a047f06945fa656ebedde67819945b28c" title="Imports the given file and returns the imported data.">ReadFile()</a>.  <a href="class_assimp_1_1_base_importer.html#a2ecaa6b808b2b282cb6aa321970a2ad3">More...</a><br /></td></tr>
<tr class="separator:a2ecaa6b808b2b282cb6aa321970a2ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94970abc42b694396afb300a45ffeb73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a94970abc42b694396afb300a45ffeb73">Throw_CloseNotFound</a> (const std::string &amp;nodeName)</td></tr>
<tr class="separator:a94970abc42b694396afb300a45ffeb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c4f7d3bbc6de78b05aa851a96d209b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a47c4f7d3bbc6de78b05aa851a96d209b">Throw_ID_NotFound</a> (const std::string &amp;pID) const</td></tr>
<tr class="separator:a47c4f7d3bbc6de78b05aa851a96d209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c2aa30037c715abc4b9f161bc0f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#abd0c2aa30037c715abc4b9f161bc0f97">Throw_IncorrectAttr</a> (const std::string &amp;nodeName, const std::string &amp;pAttrName)</td></tr>
<tr class="separator:abd0c2aa30037c715abc4b9f161bc0f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bcbbc4cb2a41522eb51435e2b2da3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a79bcbbc4cb2a41522eb51435e2b2da3b">Throw_IncorrectAttrValue</a> (const std::string &amp;nodeName, const std::string &amp;pAttrName)</td></tr>
<tr class="separator:a79bcbbc4cb2a41522eb51435e2b2da3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a52e0c498a0e2fea1cdf31a08d8a7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4a52e0c498a0e2fea1cdf31a08d8a7d1">Throw_MoreThanOnceDefined</a> (const std::string &amp;nodeName, const std::string &amp;pNodeType, const std::string &amp;pDescription)</td></tr>
<tr class="separator:a4a52e0c498a0e2fea1cdf31a08d8a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393394ef52250e7ce09ef77455192684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a393394ef52250e7ce09ef77455192684">XML_CheckNode_MustHaveChildren</a> (pugi::xml_node &amp;node)</td></tr>
<tr class="separator:a393394ef52250e7ce09ef77455192684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c57be60be98d108cabd6a784cf9aae4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a3c57be60be98d108cabd6a784cf9aae4">XML_SearchNode</a> (const std::string &amp;nodeName)</td></tr>
<tr class="separator:a3c57be60be98d108cabd6a784cf9aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a32623af462fcf73fd3c665ca4d866d0f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a32623af462fcf73fd3c665ca4d866d0f">CheckMagicToken</a> (<a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler, const std::string &amp;pFile, const void *magic, unsigned int num, unsigned int offset=0, unsigned int size=4)</td></tr>
<tr class="memdesc:a32623af462fcf73fd3c665ca4d866d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file starts with one or more magic tokens.  <a href="class_assimp_1_1_base_importer.html#a32623af462fcf73fd3c665ca4d866d0f">More...</a><br /></td></tr>
<tr class="separator:a32623af462fcf73fd3c665ca4d866d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8c81533de987dd7acea6874ad918c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a3cd8c81533de987dd7acea6874ad918c">ConvertToUTF8</a> (std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:a3cd8c81533de987dd7acea6874ad918c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An utility for all text file loaders.  <a href="class_assimp_1_1_base_importer.html#a3cd8c81533de987dd7acea6874ad918c">More...</a><br /></td></tr>
<tr class="separator:a3cd8c81533de987dd7acea6874ad918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7c9788930c44aa40c7448d61a862d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#ad9a7c9788930c44aa40c7448d61a862d">ConvertUTF8toISO8859_1</a> (std::string &amp;data)</td></tr>
<tr class="memdesc:ad9a7c9788930c44aa40c7448d61a862d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An utility for all text file loaders.  <a href="class_assimp_1_1_base_importer.html#ad9a7c9788930c44aa40c7448d61a862d">More...</a><br /></td></tr>
<tr class="separator:ad9a7c9788930c44aa40c7448d61a862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce01553ca65d8cc8f1efc2174845d67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ce01553ca65d8cc8f1efc2174845d67"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a3ce01553ca65d8cc8f1efc2174845d67">CopyVector</a> (std::vector&lt; std::unique_ptr&lt; T &gt; &gt; &amp;vec, T **&amp;out, unsigned int &amp;outLength)</td></tr>
<tr class="memdesc:a3ce01553ca65d8cc8f1efc2174845d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to move a std::vector of unique_ptrs into a <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> array.  <a href="class_assimp_1_1_base_importer.html#a3ce01553ca65d8cc8f1efc2174845d67">More...</a><br /></td></tr>
<tr class="separator:a3ce01553ca65d8cc8f1efc2174845d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1067a6780d7d6dbe457fef8abdb66a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc1067a6780d7d6dbe457fef8abdb66a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#abc1067a6780d7d6dbe457fef8abdb66a">CopyVector</a> (std::vector&lt; T &gt; &amp;vec, T *&amp;out, unsigned int &amp;outLength)</td></tr>
<tr class="memdesc:abc1067a6780d7d6dbe457fef8abdb66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to move a std::vector into a <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> array.  <a href="class_assimp_1_1_base_importer.html#abc1067a6780d7d6dbe457fef8abdb66a">More...</a><br /></td></tr>
<tr class="separator:abc1067a6780d7d6dbe457fef8abdb66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3954284d75f9fe30f5ff1758ecd2faeb"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a3954284d75f9fe30f5ff1758ecd2faeb">GetExtension</a> (const std::string &amp;pFile)</td></tr>
<tr class="memdesc:a3954284d75f9fe30f5ff1758ecd2faeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract file extension from a string.  <a href="class_assimp_1_1_base_importer.html#a3954284d75f9fe30f5ff1758ecd2faeb">More...</a><br /></td></tr>
<tr class="separator:a3954284d75f9fe30f5ff1758ecd2faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caed29cb9fa2d1e0aa0da2a17851ca2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a6caed29cb9fa2d1e0aa0da2a17851ca2">SearchFileHeaderForToken</a> (<a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOSystem, const std::string &amp;file, const char **tokens, unsigned int numTokens, unsigned int searchBytes=200, bool tokensSol=false, bool noAlphaBeforeTokens=false)</td></tr>
<tr class="memdesc:a6caed29cb9fa2d1e0aa0da2a17851ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility for <a class="el" href="class_assimp_1_1_base_importer.html#a13588d3396ba5b7ed1f1cb46e0945cfd" title="Returns whether the class can handle the format of the given file.">CanRead()</a>.  <a href="class_assimp_1_1_base_importer.html#a6caed29cb9fa2d1e0aa0da2a17851ca2">More...</a><br /></td></tr>
<tr class="separator:a6caed29cb9fa2d1e0aa0da2a17851ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de9d21d35c9060480142dc536ce5352"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a2de9d21d35c9060480142dc536ce5352">SimpleExtensionCheck</a> (const std::string &amp;pFile, const char *ext0, const char *ext1=nullptr, const char *ext2=nullptr)</td></tr>
<tr class="memdesc:a2de9d21d35c9060480142dc536ce5352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file has a specific file extension.  <a href="class_assimp_1_1_base_importer.html#a2de9d21d35c9060480142dc536ce5352">More...</a><br /></td></tr>
<tr class="separator:a2de9d21d35c9060480142dc536ce5352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c43dc005eb52d2902d13f1a475ec9cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a1c43dc005eb52d2902d13f1a475ec9cd">TextFileToBuffer</a> (<a class="el" href="class_assimp_1_1_i_o_stream.html">IOStream</a> *stream, std::vector&lt; char &gt; &amp;data, <a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7">TextFileMode</a> mode=<a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7ae507341521279743797bdce9f7a21081">FORBID_EMPTY</a>)</td></tr>
<tr class="memdesc:a1c43dc005eb52d2902d13f1a475ec9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for text file loaders which copies the contents of the file into a memory buffer and converts it to our UTF8 representation.  <a href="class_assimp_1_1_base_importer.html#a1c43dc005eb52d2902d13f1a475ec9cd">More...</a><br /></td></tr>
<tr class="separator:a1c43dc005eb52d2902d13f1a475ec9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac43f3495d597a22da47ea894f5432016"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#ac43f3495d597a22da47ea894f5432016">importerUnits</a></td></tr>
<tr class="memdesc:ac43f3495d597a22da47ea894f5432016"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> unit conversions available NOTE: Valid options are initialised in the constructor in the implementation file to work around a VS2013 compiler bug if support for that compiler is dropped in the future initialisation can be moved back here.  <a href="class_assimp_1_1_base_importer.html#ac43f3495d597a22da47ea894f5432016">More...</a><br /></td></tr>
<tr class="separator:ac43f3495d597a22da47ea894f5432016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a15fb4512ad41a241a3b8de3fa63c0434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a15fb4512ad41a241a3b8de3fa63c0434">applicationUnits</a> = ImporterUnits::M</td></tr>
<tr class="separator:a15fb4512ad41a241a3b8de3fa63c0434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85971f80c5f45fef8c3a3395e4bbe14"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#af85971f80c5f45fef8c3a3395e4bbe14">fileScale</a> = 1.0</td></tr>
<tr class="separator:af85971f80c5f45fef8c3a3395e4bbe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bb9d0bff964c79b625c754b3adb04c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#ad5bb9d0bff964c79b625c754b3adb04c">importerScale</a> = 1.0</td></tr>
<tr class="separator:ad5bb9d0bff964c79b625c754b3adb04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2c9b86479c0c165e5d84d733e53373"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#abd2c9b86479c0c165e5d84d733e53373">m_ErrorText</a></td></tr>
<tr class="memdesc:abd2c9b86479c0c165e5d84d733e53373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error description in case there was one.  <a href="class_assimp_1_1_base_importer.html#abd2c9b86479c0c165e5d84d733e53373">More...</a><br /></td></tr>
<tr class="separator:abd2c9b86479c0c165e5d84d733e53373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf84fb733992558272add378e7d9525"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a7bf84fb733992558272add378e7d9525">m_Exception</a></td></tr>
<tr class="memdesc:a7bf84fb733992558272add378e7d9525"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception, in case there was one.  <a href="class_assimp_1_1_base_importer.html#a7bf84fb733992558272add378e7d9525">More...</a><br /></td></tr>
<tr class="separator:a7bf84fb733992558272add378e7d9525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17ba9eee14fcdfe2c6f45bf940139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#aeb17ba9eee14fcdfe2c6f45bf940139d">m_progress</a></td></tr>
<tr class="memdesc:aeb17ba9eee14fcdfe2c6f45bf940139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently set progress handler.  <a href="class_assimp_1_1_base_importer.html#aeb17ba9eee14fcdfe2c6f45bf940139d">More...</a><br /></td></tr>
<tr class="separator:aeb17ba9eee14fcdfe2c6f45bf940139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a879168a4cc481955fb3c769ecc3dec86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a879168a4cc481955fb3c769ecc3dec86">AMFMetaDataArray</a> = std::vector&lt; <a class="el" href="struct_a_m_f_metadata.html">AMFMetadata</a> * &gt;</td></tr>
<tr class="separator:a879168a4cc481955fb3c769ecc3dec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04a2e9feccd56ee71a812febac3d4ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">MeshArray</a> = std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;</td></tr>
<tr class="separator:ac04a2e9feccd56ee71a812febac3d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4211f7976525bf3ce722a4190d4dc0b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">NodeArray</a> = std::vector&lt; <a class="el" href="structai_node.html">aiNode</a> * &gt;</td></tr>
<tr class="separator:a4211f7976525bf3ce722a4190d4dc0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9bf8b7916ee711a3b95377a7b54e87c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a9bf8b7916ee711a3b95377a7b54e87c2">Clear</a> ()</td></tr>
<tr class="memdesc:a9bf8b7916ee711a3b95377a7b54e87c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all temporary data.  <a href="class_assimp_1_1_a_m_f_importer.html#a9bf8b7916ee711a3b95377a7b54e87c2">More...</a><br /></td></tr>
<tr class="separator:a9bf8b7916ee711a3b95377a7b54e87c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d517d7b22911bf20087351922c0591c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a0d517d7b22911bf20087351922c0591c">ParseHelper_Decode_Base64</a> (const std::string &amp;pInputBase64, std::vector&lt; uint8_t &gt; &amp;pOutputData) const</td></tr>
<tr class="memdesc:a0d517d7b22911bf20087351922c0591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode Base64-encoded data.  <a href="class_assimp_1_1_a_m_f_importer.html#a0d517d7b22911bf20087351922c0591c">More...</a><br /></td></tr>
<tr class="separator:a0d517d7b22911bf20087351922c0591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ee340fccb7d16276be2304274e951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ab35ee340fccb7d16276be2304274e951">ParseNode_Color</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:ab35ee340fccb7d16276be2304274e951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;color&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#ab35ee340fccb7d16276be2304274e951">More...</a><br /></td></tr>
<tr class="separator:ab35ee340fccb7d16276be2304274e951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5db3d6b246b2de883328d69ffc5b574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ae5db3d6b246b2de883328d69ffc5b574">ParseNode_Constellation</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:ae5db3d6b246b2de883328d69ffc5b574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;constellation&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#ae5db3d6b246b2de883328d69ffc5b574">More...</a><br /></td></tr>
<tr class="separator:ae5db3d6b246b2de883328d69ffc5b574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf2cf14c2da553bdd8e3cdf28e334e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aecf2cf14c2da553bdd8e3cdf28e334e3">ParseNode_Coordinates</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:aecf2cf14c2da553bdd8e3cdf28e334e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;coordinates&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#aecf2cf14c2da553bdd8e3cdf28e334e3">More...</a><br /></td></tr>
<tr class="separator:aecf2cf14c2da553bdd8e3cdf28e334e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d552bef0fbbe6234d06390ff2e95ac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4d552bef0fbbe6234d06390ff2e95ac5">ParseNode_Edge</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a4d552bef0fbbe6234d06390ff2e95ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;edge&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a4d552bef0fbbe6234d06390ff2e95ac5">More...</a><br /></td></tr>
<tr class="separator:a4d552bef0fbbe6234d06390ff2e95ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07eec04215a6fed1829bc9bbaf227ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aa07eec04215a6fed1829bc9bbaf227ca">ParseNode_Instance</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:aa07eec04215a6fed1829bc9bbaf227ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;instance&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#aa07eec04215a6fed1829bc9bbaf227ca">More...</a><br /></td></tr>
<tr class="separator:aa07eec04215a6fed1829bc9bbaf227ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c55ffe48adcc289902d42cb33ba36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a65c55ffe48adcc289902d42cb33ba36f">ParseNode_Material</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a65c55ffe48adcc289902d42cb33ba36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;material&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a65c55ffe48adcc289902d42cb33ba36f">More...</a><br /></td></tr>
<tr class="separator:a65c55ffe48adcc289902d42cb33ba36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab93b17442c3146d70132dcfa0c1cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aeab93b17442c3146d70132dcfa0c1cab">ParseNode_Mesh</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:aeab93b17442c3146d70132dcfa0c1cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;mesh&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#aeab93b17442c3146d70132dcfa0c1cab">More...</a><br /></td></tr>
<tr class="separator:aeab93b17442c3146d70132dcfa0c1cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab0396ba463b3d7dfcbd510ba8a855b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a1ab0396ba463b3d7dfcbd510ba8a855b">ParseNode_Metadata</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a1ab0396ba463b3d7dfcbd510ba8a855b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;metadata&gt; node.  <a href="class_assimp_1_1_a_m_f_importer.html#a1ab0396ba463b3d7dfcbd510ba8a855b">More...</a><br /></td></tr>
<tr class="separator:a1ab0396ba463b3d7dfcbd510ba8a855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9add45929aa7a99e3583eec272f548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a2e9add45929aa7a99e3583eec272f548">ParseNode_Object</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a2e9add45929aa7a99e3583eec272f548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;object&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a2e9add45929aa7a99e3583eec272f548">More...</a><br /></td></tr>
<tr class="separator:a2e9add45929aa7a99e3583eec272f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc01c7480ccc3ab59d9cb67dba909b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#adc01c7480ccc3ab59d9cb67dba909b2e">ParseNode_Root</a> ()</td></tr>
<tr class="memdesc:adc01c7480ccc3ab59d9cb67dba909b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;AMF&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#adc01c7480ccc3ab59d9cb67dba909b2e">More...</a><br /></td></tr>
<tr class="separator:adc01c7480ccc3ab59d9cb67dba909b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa096762f60c96296adaed3ee4ee5b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a8aa096762f60c96296adaed3ee4ee5b1">ParseNode_TexMap</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node, const bool pUseOldName=false)</td></tr>
<tr class="memdesc:a8aa096762f60c96296adaed3ee4ee5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;texmap&gt; of &lt;map&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a8aa096762f60c96296adaed3ee4ee5b1">More...</a><br /></td></tr>
<tr class="separator:a8aa096762f60c96296adaed3ee4ee5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1debab9698977540e9f35a8a7412edb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a1debab9698977540e9f35a8a7412edb7">ParseNode_Texture</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a1debab9698977540e9f35a8a7412edb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;texture&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a1debab9698977540e9f35a8a7412edb7">More...</a><br /></td></tr>
<tr class="separator:a1debab9698977540e9f35a8a7412edb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2aab7a9126cbcbfc3b867038b1fb1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#acb2aab7a9126cbcbfc3b867038b1fb1d">ParseNode_Triangle</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:acb2aab7a9126cbcbfc3b867038b1fb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;triangle&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#acb2aab7a9126cbcbfc3b867038b1fb1d">More...</a><br /></td></tr>
<tr class="separator:acb2aab7a9126cbcbfc3b867038b1fb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232d82f420e1a621005a214d5b3bf36a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a232d82f420e1a621005a214d5b3bf36a">ParseNode_Vertex</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a232d82f420e1a621005a214d5b3bf36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;vertex&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a232d82f420e1a621005a214d5b3bf36a">More...</a><br /></td></tr>
<tr class="separator:a232d82f420e1a621005a214d5b3bf36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b346b6913b895900f332278164f16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a963b346b6913b895900f332278164f16">ParseNode_Vertices</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:a963b346b6913b895900f332278164f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;vertices&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#a963b346b6913b895900f332278164f16">More...</a><br /></td></tr>
<tr class="separator:a963b346b6913b895900f332278164f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4a3620a8189568cef22bd0bf0b2eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ada4a3620a8189568cef22bd0bf0b2eb7">ParseNode_Volume</a> (<a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;node)</td></tr>
<tr class="memdesc:ada4a3620a8189568cef22bd0bf0b2eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse &lt;volume&gt; node of the file.  <a href="class_assimp_1_1_a_m_f_importer.html#ada4a3620a8189568cef22bd0bf0b2eb7">More...</a><br /></td></tr>
<tr class="separator:ada4a3620a8189568cef22bd0bf0b2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abc1eb8eda4f3cbc1891a55c99d4062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a6abc1eb8eda4f3cbc1891a55c99d4062">Postprocess_AddMetadata</a> (const <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a879168a4cc481955fb3c769ecc3dec86">AMFMetaDataArray</a> &amp;pMetadataList, <a class="el" href="structai_node.html">aiNode</a> &amp;pSceneNode) const</td></tr>
<tr class="memdesc:a6abc1eb8eda4f3cbc1891a55c99d4062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if child elements of node element is metadata and add it to scene node.  <a href="class_assimp_1_1_a_m_f_importer.html#a6abc1eb8eda4f3cbc1891a55c99d4062">More...</a><br /></td></tr>
<tr class="separator:a6abc1eb8eda4f3cbc1891a55c99d4062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20be498c328b4665a5abe0e4088b840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aa20be498c328b4665a5abe0e4088b840">Postprocess_BuildConstellation</a> (<a class="el" href="struct_a_m_f_constellation.html">AMFConstellation</a> &amp;pConstellation, <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">NodeArray</a> &amp;nodeArray) const</td></tr>
<tr class="memdesc:aa20be498c328b4665a5abe0e4088b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and add to <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a>'s list new part of scene graph defined by &lt;constellation&gt;.  <a href="class_assimp_1_1_a_m_f_importer.html#aa20be498c328b4665a5abe0e4088b840">More...</a><br /></td></tr>
<tr class="separator:aa20be498c328b4665a5abe0e4088b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7a0a22a7fad58a1704dbaba4c2b832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aaa7a0a22a7fad58a1704dbaba4c2b832">Postprocess_BuildMaterial</a> (const <a class="el" href="struct_a_m_f_material.html">AMFMaterial</a> &amp;pMaterial)</td></tr>
<tr class="memdesc:aaa7a0a22a7fad58a1704dbaba4c2b832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert material from <a class="el" href="struct_c_a_m_f_importer___node_element___material.html">CAMFImporter_NodeElement_Material</a> to <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a>.  <a href="class_assimp_1_1_a_m_f_importer.html#aaa7a0a22a7fad58a1704dbaba4c2b832">More...</a><br /></td></tr>
<tr class="separator:aaa7a0a22a7fad58a1704dbaba4c2b832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b45b92b3872bae9b8c03abae2df90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ae47b45b92b3872bae9b8c03abae2df90">Postprocess_BuildMeshSet</a> (const <a class="el" href="struct_a_m_f_mesh.html">AMFMesh</a> &amp;pNodeElement, const std::vector&lt; <a class="el" href="vector3_8h.html#af90f71b9e287bdc258b1dd86656d8dfe">aiVector3D</a> &gt; &amp;pVertexCoordinateArray, const std::vector&lt; <a class="el" href="struct_a_m_f_color.html">AMFColor</a> * &gt; &amp;pVertexColorArray, const <a class="el" href="struct_a_m_f_color.html">AMFColor</a> *pObjectColor, <a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">MeshArray</a> &amp;pMeshList, <a class="el" href="structai_node.html">aiNode</a> &amp;pSceneNode)</td></tr>
<tr class="memdesc:ae47b45b92b3872bae9b8c03abae2df90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mesh for every &lt;volume&gt; in &lt;mesh&gt;.  <a href="class_assimp_1_1_a_m_f_importer.html#ae47b45b92b3872bae9b8c03abae2df90">More...</a><br /></td></tr>
<tr class="separator:ae47b45b92b3872bae9b8c03abae2df90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a7b2af896f562a53b6aa3a56015d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a85a7b2af896f562a53b6aa3a56015d1d">Postprocess_BuildNodeAndObject</a> (const <a class="el" href="struct_a_m_f_object.html">AMFObject</a> &amp;pNodeElement, <a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">MeshArray</a> &amp;meshList, <a class="el" href="structai_node.html">aiNode</a> **pSceneNode)</td></tr>
<tr class="memdesc:a85a7b2af896f562a53b6aa3a56015d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To create <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a> and <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a> for it from &lt;object&gt;.  <a href="class_assimp_1_1_a_m_f_importer.html#a85a7b2af896f562a53b6aa3a56015d1d">More...</a><br /></td></tr>
<tr class="separator:a85a7b2af896f562a53b6aa3a56015d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32158ec90fd685d0f7b4a816c49fe427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a32158ec90fd685d0f7b4a816c49fe427">Postprocess_BuildScene</a> (<a class="el" href="structai_scene.html">aiScene</a> *pScene)</td></tr>
<tr class="memdesc:a32158ec90fd685d0f7b4a816c49fe427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> scene graph in <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> from collected data.  <a href="class_assimp_1_1_a_m_f_importer.html#a32158ec90fd685d0f7b4a816c49fe427">More...</a><br /></td></tr>
<tr class="separator:a32158ec90fd685d0f7b4a816c49fe427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc2e39957e2021aa50c16ff8014cc3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a7dc2e39957e2021aa50c16ff8014cc3e">PostprocessHelper_CreateMeshDataArray</a> (const <a class="el" href="struct_a_m_f_mesh.html">AMFMesh</a> &amp;pNodeElement, std::vector&lt; <a class="el" href="vector3_8h.html#af90f71b9e287bdc258b1dd86656d8dfe">aiVector3D</a> &gt; &amp;pVertexCoordinateArray, std::vector&lt; <a class="el" href="struct_a_m_f_color.html">AMFColor</a> * &gt; &amp;pVertexColorArray) const</td></tr>
<tr class="memdesc:a7dc2e39957e2021aa50c16ff8014cc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data stored in &lt;vertices&gt; and place it to arrays.  <a href="class_assimp_1_1_a_m_f_importer.html#a7dc2e39957e2021aa50c16ff8014cc3e">More...</a><br /></td></tr>
<tr class="separator:a7dc2e39957e2021aa50c16ff8014cc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9891e1102887b77581ea1b6cd3bb374"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ab9891e1102887b77581ea1b6cd3bb374">PostprocessHelper_GetTextureID_Or_Create</a> (const std::string &amp;pID_R, const std::string &amp;pID_G, const std::string &amp;pID_B, const std::string &amp;pID_A)</td></tr>
<tr class="memdesc:ab9891e1102887b77581ea1b6cd3bb374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return converted texture ID which related to specified source textures ID's.  <a href="class_assimp_1_1_a_m_f_importer.html#ab9891e1102887b77581ea1b6cd3bb374">More...</a><br /></td></tr>
<tr class="separator:ab9891e1102887b77581ea1b6cd3bb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435fadd3d6f5b78ff2ef9ee3d1914157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a435fadd3d6f5b78ff2ef9ee3d1914157">PostprocessHelper_SplitFacesByTextureID</a> (std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html">SComplexFace</a> &gt; &amp;pInputList, std::list&lt; std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html">SComplexFace</a> &gt;&gt; &amp;pOutputList_Separated)</td></tr>
<tr class="memdesc:a435fadd3d6f5b78ff2ef9ee3d1914157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate input list by texture IDs.  <a href="class_assimp_1_1_a_m_f_importer.html#a435fadd3d6f5b78ff2ef9ee3d1914157">More...</a><br /></td></tr>
<tr class="separator:a435fadd3d6f5b78ff2ef9ee3d1914157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ad05fde79c32af5af694f976657a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_base_importer.html#a1d1ad05fde79c32af5af694f976657a7">UpdateImporterScale</a> (<a class="el" href="class_assimp_1_1_importer.html">Importer</a> *pImp)</td></tr>
<tr class="separator:a1d1ad05fde79c32af5af694f976657a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae11f52d00bc07e633983ffe7c1beea22"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ae11f52d00bc07e633983ffe7c1beea22">mMaterial_Converted</a></td></tr>
<tr class="memdesc:ae11f52d00bc07e633983ffe7c1beea22"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of converted materials for postprocessing step.  <a href="class_assimp_1_1_a_m_f_importer.html#ae11f52d00bc07e633983ffe7c1beea22">More...</a><br /></td></tr>
<tr class="separator:ae11f52d00bc07e633983ffe7c1beea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7de0482677984a39d79dce565758a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aef7de0482677984a39d79dce565758a3">mNodeElement_Cur</a></td></tr>
<tr class="memdesc:aef7de0482677984a39d79dce565758a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current element.  <a href="class_assimp_1_1_a_m_f_importer.html#aef7de0482677984a39d79dce565758a3">More...</a><br /></td></tr>
<tr class="separator:aef7de0482677984a39d79dce565758a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea60ab11c46fbfb41ae5d2da2769443b"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#aea60ab11c46fbfb41ae5d2da2769443b">mNodeElement_List</a></td></tr>
<tr class="memdesc:aea60ab11c46fbfb41ae5d2da2769443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">All elements of scene graph.  <a href="class_assimp_1_1_a_m_f_importer.html#aea60ab11c46fbfb41ae5d2da2769443b">More...</a><br /></td></tr>
<tr class="separator:aea60ab11c46fbfb41ae5d2da2769443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d9ceefd78646dad36a9cf6f7ed036f"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___texture.html">SPP_Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a21d9ceefd78646dad36a9cf6f7ed036f">mTexture_Converted</a></td></tr>
<tr class="memdesc:a21d9ceefd78646dad36a9cf6f7ed036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of converted textures for postprocessing step.  <a href="class_assimp_1_1_a_m_f_importer.html#a21d9ceefd78646dad36a9cf6f7ed036f">More...</a><br /></td></tr>
<tr class="separator:a21d9ceefd78646dad36a9cf6f7ed036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328ba05ba9b5ed06ddaaf955464dc210"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a328ba05ba9b5ed06ddaaf955464dc210">mUnit</a></td></tr>
<tr class="separator:a328ba05ba9b5ed06ddaaf955464dc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c45f2ccb689ac83a49f465efbcc21"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a5e1c45f2ccb689ac83a49f465efbcc21">mVersion</a></td></tr>
<tr class="separator:a5e1c45f2ccb689ac83a49f465efbcc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba4b0a07092f973a8f9c1c10663d6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_assimp.html#a6295df0173c66269feae004611f499a2">XmlParser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a7ba4b0a07092f973a8f9c1c10663d6f0">mXmlParser</a></td></tr>
<tr class="separator:a7ba4b0a07092f973a8f9c1c10663d6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a0d7f6f7a8971bfcc30dc327daf8e03f5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a0d7f6f7a8971bfcc30dc327daf8e03f5">Description</a></td></tr>
<tr class="separator:a0d7f6f7a8971bfcc30dc327daf8e03f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that holding scene graph which include: geometry, metadata, materials etc. </p>
<p>Implementing features.</p>
<p>Limitations.</p>
<ol type="1">
<li>When for texture mapping used set of source textures (r, g, b, a) not only one then attribute "tiled" for all set will be true if it true in any of source textures. Example. Triangle use for texture mapping three textures. Two of them has "tiled" set to false and one - set to true. In scene all three textures will be tiled.</li>
</ol>
<p>Unsupported features:</p><ol type="1">
<li>Node &lt;composite&gt;, formulas in &lt;composite&gt; and &lt;color&gt;. For implementing this feature can be used expression parser "muParser" like in project "amf_tools".</li>
<li>Attribute "profile" in node &lt;color&gt;.</li>
<li>Curved geometry: &lt;edge&gt;, &lt;normal&gt; and children nodes of them.</li>
<li>Attributes: "unit" and "version" in &lt;amf&gt; read but do nothing.</li>
<li>&lt;metadata&gt; stored only for root node &lt;amf&gt;.</li>
<li>Color averaging of vertices for which &lt;triangle&gt;'s set different colors.</li>
</ol>
<p>Supported nodes: General: &lt;amf&gt;; &lt;constellation&gt;; &lt;instance&gt; and children &lt;deltax&gt;, &lt;deltay&gt;, &lt;deltaz&gt;, &lt;rx&gt;, &lt;ry&gt;, &lt;rz&gt;; &lt;metadata&gt;;</p>
<p>Geometry: &lt;object&gt;; &lt;mesh&gt;; &lt;vertices&gt;; &lt;vertex&gt;; &lt;coordinates&gt; and children &lt;x&gt;, &lt;y&gt;, &lt;z&gt;; &lt;volume&gt;; &lt;triangle&gt; and children &lt;v1&gt;, &lt;v2&gt;, &lt;v3&gt;;</p>
<p>Material: &lt;color&gt; and children &lt;r&gt;, &lt;g&gt;, <b>, ; &lt;texture&gt;; &lt;material&gt;; two variants of texture coordinates: new - &lt;texmap&gt; and children &lt;utex1&gt;, &lt;utex2&gt;, &lt;utex3&gt;, &lt;vtex1&gt;, &lt;vtex2&gt;, &lt;vtex3&gt; old - &lt;map&gt; and children &lt;u1&gt;, &lt;u2&gt;, &lt;u3&gt;, &lt;v1&gt;, &lt;v2&gt;, &lt;v3&gt; </b></p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a879168a4cc481955fb3c769ecc3dec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879168a4cc481955fb3c769ecc3dec86">&#9670;&nbsp;</a></span>AMFMetaDataArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a879168a4cc481955fb3c769ecc3dec86">Assimp::AMFImporter::AMFMetaDataArray</a> =  std::vector&lt;<a class="el" href="struct_a_m_f_metadata.html">AMFMetadata</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04a2e9feccd56ee71a812febac3d4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04a2e9feccd56ee71a812febac3d4ab">&#9670;&nbsp;</a></span>MeshArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">Assimp::AMFImporter::MeshArray</a> =  std::vector&lt;<a class="el" href="structai_mesh.html">aiMesh</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4211f7976525bf3ce722a4190d4dc0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4211f7976525bf3ce722a4190d4dc0b0">&#9670;&nbsp;</a></span>NodeArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">Assimp::AMFImporter::NodeArray</a> =  std::vector&lt;<a class="el" href="structai_node.html">aiNode</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6b225ea9aa92433ec03cb41492a0d451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b225ea9aa92433ec03cb41492a0d451">&#9670;&nbsp;</a></span>ImporterUnits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">Assimp::BaseImporter::ImporterUnits</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6b225ea9aa92433ec03cb41492a0d451af84e338c6e9a678ed63b8b2b7de9ef02"></a>M&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6b225ea9aa92433ec03cb41492a0d451a1633eb908b6889de4de75080bbf13229"></a>MM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6b225ea9aa92433ec03cb41492a0d451af5fe8cb0ad373c368ac0d87e9141a833"></a>CM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6b225ea9aa92433ec03cb41492a0d451ace3a659f5caad10cf4ac6f2de87d35c3"></a>INCHES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6b225ea9aa92433ec03cb41492a0d451ae90aa4e961f527f988365ee77d476118"></a>FEET&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9fe6b47937a7c897536cac1513b65eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe6b47937a7c897536cac1513b65eb7">&#9670;&nbsp;</a></span>TextFileMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7">Assimp::BaseImporter::TextFileMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to define, if empty files are ok or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fe6b47937a7c897536cac1513b65eb7af10ad62259d2e54eff440019b345e309"></a>ALLOW_EMPTY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9fe6b47937a7c897536cac1513b65eb7ae507341521279743797bdce9f7a21081"></a>FORBID_EMPTY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a773ef728497dcfd14ae4df39304d3b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773ef728497dcfd14ae4df39304d3b3e">&#9670;&nbsp;</a></span>AMFImporter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::AMFImporter::AMFImporter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="ae7f9a71e68764d6e3d5b151173cda420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f9a71e68764d6e3d5b151173cda420">&#9670;&nbsp;</a></span>~AMFImporter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::AMFImporter::~AMFImporter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="a7029ced8aacd6661286e747d9f6c08fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7029ced8aacd6661286e747d9f6c08fd">&#9670;&nbsp;</a></span>AMFImporter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::AMFImporter::AMFImporter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a> &amp;&#160;</td>
          <td class="paramname"><em>pScene</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85a2e04a7d988def5ddc00c2f65532f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a2e04a7d988def5ddc00c2f65532f7">&#9670;&nbsp;</a></span>CanRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::AMFImporter::CanRead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the class can handle the format of the given file. </p>
<p>The implementation should be as quick as possible. A check for the file extension is enough. If no suitable loader is found with this strategy, <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a85a2e04a7d988def5ddc00c2f65532f7" title="Returns whether the class can handle the format of the given file.">CanRead()</a> is called again, the 'checkSig' parameter set to true this time. Now the implementation is expected to perform a full check of the file structure, possibly searching the first bytes of the file for magic identifiers or keywords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Path and file name of the file to be examined. </td></tr>
    <tr><td class="paramname">pIOHandler</td><td>The IO handler to use for accessing any file. </td></tr>
    <tr><td class="paramname">checkSig</td><td>Set to true if this method is called a second time. This time, the implementation may take more time to examine the contents of the file to be loaded for magic bytes, keywords, etc to be able to load files with unknown/not existent file extensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the class can read this file, false if not. </dd></dl>

<p>Implements <a class="el" href="class_assimp_1_1_base_importer.html#a13588d3396ba5b7ed1f1cb46e0945cfd">Assimp::BaseImporter</a>.</p>

</div>
</div>
<a id="a32623af462fcf73fd3c665ca4d866d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32623af462fcf73fd3c665ca4d866d0f">&#9670;&nbsp;</a></span>CheckMagicToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BaseImporter::CheckMagicToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>magic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a file starts with one or more magic tokens. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Input file </td></tr>
    <tr><td class="paramname">pIOHandler</td><td>IO system to be used </td></tr>
    <tr><td class="paramname">magic</td><td>n magic tokens @params num Size of magic </td></tr>
    <tr><td class="paramname">offset</td><td>Offset from file start where tokens are located </td></tr>
    <tr><td class="paramname">Size</td><td>of one token, in bytes. Maximally 16 bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if one of the given tokens was found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For convenience, the check is also performed for the byte-swapped variant of all tokens (big endian). Only for tokens of size 2,4. </dd></dl>

</div>
</div>
<a id="a9bf8b7916ee711a3b95377a7b54e87c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf8b7916ee711a3b95377a7b54e87c2">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all temporary data. </p>

</div>
</div>
<a id="a3cd8c81533de987dd7acea6874ad918c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8c81533de987dd7acea6874ad918c">&#9670;&nbsp;</a></span>ConvertToUTF8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseImporter::ConvertToUTF8 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An utility for all text file loaders. </p>
<p>It converts a file to our UTF8 character set. Errors are reported, but ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>File buffer to be converted to UTF8 data. The buffer is resized as appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9a7c9788930c44aa40c7448d61a862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a7c9788930c44aa40c7448d61a862d">&#9670;&nbsp;</a></span>ConvertUTF8toISO8859_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseImporter::ConvertUTF8toISO8859_1 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An utility for all text file loaders. </p>
<p>It converts a file from our UTF8 character set back to ISO-8859-1. Errors are reported, but ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>File buffer to be converted from UTF8 to ISO-8859-1. The buffer is resized as appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce01553ca65d8cc8f1efc2174845d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce01553ca65d8cc8f1efc2174845d67">&#9670;&nbsp;</a></span>CopyVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> void Assimp::BaseImporter::CopyVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to move a std::vector of unique_ptrs into a <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of unique_ptrs to be moved </td></tr>
    <tr><td class="paramname">out</td><td>The output pointer to the allocated array. </td></tr>
    <tr><td class="paramname">numOut</td><td>The output count of elements copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1067a6780d7d6dbe457fef8abdb66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1067a6780d7d6dbe457fef8abdb66a">&#9670;&nbsp;</a></span>CopyVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> void Assimp::BaseImporter::CopyVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to move a std::vector into a <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to be moved </td></tr>
    <tr><td class="paramname">out</td><td>The output pointer to the allocated array. </td></tr>
    <tr><td class="paramname">numOut</td><td>The output count of elements copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f50ef50c8ce066cfa9c1034c2161948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f50ef50c8ce066cfa9c1034c2161948">&#9670;&nbsp;</a></span>Find_ConvertedMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::AMFImporter::Find_ConvertedMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a> **&#160;</td>
          <td class="paramname"><em>pConvertedMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0fa072ffa46e867e23db2a9e2160daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fa072ffa46e867e23db2a9e2160daf">&#9670;&nbsp;</a></span>Find_ConvertedNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::AMFImporter::Find_ConvertedNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">NodeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> **&#160;</td>
          <td class="paramname"><em>pNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38726efa592db2c8fdc51f7b2cfd1bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38726efa592db2c8fdc51f7b2cfd1bf0">&#9670;&nbsp;</a></span>Find_NodeElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::AMFImporter::Find_NodeElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_m_f_node_element_base.html#a8461de95fe616786ef54db126007eb0a">AMFNodeElementBase::EType</a>&#160;</td>
          <td class="paramname"><em>pType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> **&#160;</td>
          <td class="paramname"><em>pNodeElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51876206d286fb5804a2e99ad1fcae12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51876206d286fb5804a2e99ad1fcae12">&#9670;&nbsp;</a></span>GetApplicationUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a>&amp; Assimp::BaseImporter::GetApplicationUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15c379ec3a8399551d7b379de7fc3bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c379ec3a8399551d7b379de7fc3bc1">&#9670;&nbsp;</a></span>GetErrorText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Assimp::BaseImporter::GetErrorText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error description of the last error that occurred. </p>
<p>If the error is due to a std::exception, this will return the message. Exceptions can also be accessed with <a class="el" href="class_assimp_1_1_base_importer.html#a05f9397b157ff1b56d7d360a39ca41ac" title="Returns the exception of the last exception that occurred.">GetException()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A description of the last error that occurred. An empty string if there was no error. </dd></dl>

</div>
</div>
<a id="a05f9397b157ff1b56d7d360a39ca41ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9397b157ff1b56d7d360a39ca41ac">&#9670;&nbsp;</a></span>GetException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::exception_ptr&amp; Assimp::BaseImporter::GetException </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exception of the last exception that occurred. </p>
<p>Note: Exceptions are not the only source of error details, so GetErrorText should be consulted too. </p><dl class="section return"><dt>Returns</dt><dd>The last exception that occurred. </dd></dl>

</div>
</div>
<a id="a3954284d75f9fe30f5ff1758ecd2faeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3954284d75f9fe30f5ff1758ecd2faeb">&#9670;&nbsp;</a></span>GetExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string BaseImporter::GetExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract file extension from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Input file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extension without trailing dot, all lowercase </dd></dl>

</div>
</div>
<a id="a925321c2c2fe2702854c1b1b86ad6639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925321c2c2fe2702854c1b1b86ad6639">&#9670;&nbsp;</a></span>GetExtensionList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::GetExtensionList </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>pExtensionList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21e52bc7b3d7833000737018a8301efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e52bc7b3d7833000737018a8301efc">&#9670;&nbsp;</a></span>GetFileScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Assimp::BaseImporter::GetFileScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11e10b5a345ab82b1f740e3a6f0ed575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e10b5a345ab82b1f740e3a6f0ed575">&#9670;&nbsp;</a></span>GetInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a> * Assimp::AMFImporter::GetInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by #Importer::GetImporterInfo to get a description of some loader features. </p>
<p>Importers must provide this information. </p>

<p>Implements <a class="el" href="class_assimp_1_1_base_importer.html#a070b8c3f63767ad535c8ac509b725fc4">Assimp::BaseImporter</a>.</p>

</div>
</div>
<a id="a3c0559661295085fc31d3c2b9f6a3eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0559661295085fc31d3c2b9f6a3eb9">&#9670;&nbsp;</a></span>InternReadFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::InternReadFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imports the given file into the given scene structure. </p>
<p>The function is expected to throw an ImportErrorException if there is an error. If it terminates normally, the data in <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> is expected to be correct. Override this function to implement the actual importing. <br  />
 The output scene must meet the following requirements:<br  />
 </p><ul>
<li>
At least a root node must be there, even if its only purpose is to reference one mesh. </li>
<li>
<a class="el" href="structai_mesh.html#a99d66ac0a444068c1b252b30265cbf53" title="Bitwise combination of the members of the aiPrimitiveType enum.">aiMesh::mPrimitiveTypes</a> may be 0. The types of primitives in the mesh are determined automatically in this case. </li>
<li>
the vertex data is stored in a pseudo-indexed "verbose" format. In fact this means that every vertex that is referenced by a face is unique. Or the other way round: a vertex index may not occur twice in a single <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a>. </li>
<li>
<a class="el" href="structai_animation.html#ae2bbc49320b4b75c05e23e0ab704ece7" title="Duration of the animation in ticks.">aiAnimation::mDuration</a> may be -1. <a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> determines the length of the animation automatically in this case as the length of the longest animation channel. </li>
<li>
<a class="el" href="structai_mesh.html#ab2a81bfe1731f01271ebab274a8f01c4" title="Vertex bitangents.">aiMesh::mBitangents</a> may be nullptr if tangents and normals are given. In this case bitangents are computed as the cross product between normal and tangent. </li>
<li>
There needn't be a material. If none is there a default material is generated. However, it is recommended practice for loaders to generate a default material for yourself that matches the default material setting for the file format better than <a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a>'s generic default material. Note that default materials <em>should</em> be named AI_DEFAULT_MATERIAL_NAME if they're just color-shaded or AI_DEFAULT_TEXTURED_MATERIAL_NAME if they define a (dummy) texture.  </li>
</ul>
<p>If the AI_SCENE_FLAGS_INCOMPLETE-Flag is <b>not</b> set:</p><ul>
<li>
at least one mesh must be there </li>
<li>
there may be no meshes with 0 vertices or faces </li>
</ul>
<p>This won't be checked (except by the validation step): <a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> will crash if one of the conditions is not met!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Path of the file to be imported. </td></tr>
    <tr><td class="paramname">pScene</td><td>The scene object to hold the imported data. nullptr is not a valid parameter. </td></tr>
    <tr><td class="paramname">pIOHandler</td><td>The IO handler to use for any file access. nullptr is not a valid parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_assimp_1_1_base_importer.html#ac67d9f5ceb26353d27d6be06cccad398">Assimp::BaseImporter</a>.</p>

</div>
</div>
<a id="af2110829b40afb0f82039289217879c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2110829b40afb0f82039289217879c1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a>&amp; Assimp::AMFImporter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_a_m_f_importer.html">AMFImporter</a> &amp;&#160;</td>
          <td class="paramname"><em>pScene</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2f19d53310ef5b54f5bdce46bbd098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f19d53310ef5b54f5bdce46bbd098f">&#9670;&nbsp;</a></span>ParseFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse AMF file and fill scene graph. </p>
<p>The function has no return value. Result can be found by analyzing the generated graph. Also exception can be thrown if trouble will found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFile</td><td>- name of file to be parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pIOHandler</td><td>- pointer to IO helper object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d517d7b22911bf20087351922c0591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d517d7b22911bf20087351922c0591c">&#9670;&nbsp;</a></span>ParseHelper_Decode_Base64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseHelper_Decode_Base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pInputBase64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pOutputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode Base64-encoded data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pInputBase64</td><td>- reference to input Base64-encoded string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputData</td><td>- reference to output array for decoded data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3082a3a110c6cf65d3c74b1977c037d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3082a3a110c6cf65d3c74b1977c037d5">&#9670;&nbsp;</a></span>ParseHelper_FixTruncatedFloatString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseHelper_FixTruncatedFloatString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pInStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>pOutString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c14cbd0ddc699098a71e320588ae361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c14cbd0ddc699098a71e320588ae361">&#9670;&nbsp;</a></span>ParseHelper_Node_Enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseHelper_Node_Enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a297134f091bc15389459fe2bb31d46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297134f091bc15389459fe2bb31d46aa">&#9670;&nbsp;</a></span>ParseHelper_Node_Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseHelper_Node_Exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab35ee340fccb7d16276be2304274e951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ee340fccb7d16276be2304274e951">&#9670;&nbsp;</a></span>ParseNode_Color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;color&gt; node of the file. </p>

</div>
</div>
<a id="ae5db3d6b246b2de883328d69ffc5b574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5db3d6b246b2de883328d69ffc5b574">&#9670;&nbsp;</a></span>ParseNode_Constellation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Constellation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;constellation&gt; node of the file. </p>

</div>
</div>
<a id="aecf2cf14c2da553bdd8e3cdf28e334e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf2cf14c2da553bdd8e3cdf28e334e3">&#9670;&nbsp;</a></span>ParseNode_Coordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;coordinates&gt; node of the file. </p>

</div>
</div>
<a id="a4d552bef0fbbe6234d06390ff2e95ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d552bef0fbbe6234d06390ff2e95ac5">&#9670;&nbsp;</a></span>ParseNode_Edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;edge&gt; node of the file. </p>

</div>
</div>
<a id="aa07eec04215a6fed1829bc9bbaf227ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07eec04215a6fed1829bc9bbaf227ca">&#9670;&nbsp;</a></span>ParseNode_Instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;instance&gt; node of the file. </p>

</div>
</div>
<a id="a65c55ffe48adcc289902d42cb33ba36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c55ffe48adcc289902d42cb33ba36f">&#9670;&nbsp;</a></span>ParseNode_Material()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Material </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;material&gt; node of the file. </p>

</div>
</div>
<a id="aeab93b17442c3146d70132dcfa0c1cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab93b17442c3146d70132dcfa0c1cab">&#9670;&nbsp;</a></span>ParseNode_Mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;mesh&gt; node of the file. </p>

</div>
</div>
<a id="a1ab0396ba463b3d7dfcbd510ba8a855b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab0396ba463b3d7dfcbd510ba8a855b">&#9670;&nbsp;</a></span>ParseNode_Metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;metadata&gt; node. </p>

</div>
</div>
<a id="a2e9add45929aa7a99e3583eec272f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9add45929aa7a99e3583eec272f548">&#9670;&nbsp;</a></span>ParseNode_Object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;object&gt; node of the file. </p>

</div>
</div>
<a id="adc01c7480ccc3ab59d9cb67dba909b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc01c7480ccc3ab59d9cb67dba909b2e">&#9670;&nbsp;</a></span>ParseNode_Root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;AMF&gt; node of the file. </p>

</div>
</div>
<a id="a8aa096762f60c96296adaed3ee4ee5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa096762f60c96296adaed3ee4ee5b1">&#9670;&nbsp;</a></span>ParseNode_TexMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_TexMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pUseOldName</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;texmap&gt; of &lt;map&gt; node of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUseOldName</td><td>- if true then use old name of node(and children) - &lt;map&gt;, instead of new name - &lt;texmap&gt;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1debab9698977540e9f35a8a7412edb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1debab9698977540e9f35a8a7412edb7">&#9670;&nbsp;</a></span>ParseNode_Texture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;texture&gt; node of the file. </p>

</div>
</div>
<a id="acb2aab7a9126cbcbfc3b867038b1fb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2aab7a9126cbcbfc3b867038b1fb1d">&#9670;&nbsp;</a></span>ParseNode_Triangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;triangle&gt; node of the file. </p>

</div>
</div>
<a id="a232d82f420e1a621005a214d5b3bf36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232d82f420e1a621005a214d5b3bf36a">&#9670;&nbsp;</a></span>ParseNode_Vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;vertex&gt; node of the file. </p>

</div>
</div>
<a id="a963b346b6913b895900f332278164f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963b346b6913b895900f332278164f16">&#9670;&nbsp;</a></span>ParseNode_Vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;vertices&gt; node of the file. </p>

</div>
</div>
<a id="ada4a3620a8189568cef22bd0bf0b2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4a3620a8189568cef22bd0bf0b2eb7">&#9670;&nbsp;</a></span>ParseNode_Volume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::ParseNode_Volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_assimp.html#ad9aa76cdbe59a3c057f55760f3a02c0a">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse &lt;volume&gt; node of the file. </p>

</div>
</div>
<a id="a6abc1eb8eda4f3cbc1891a55c99d4062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abc1eb8eda4f3cbc1891a55c99d4062">&#9670;&nbsp;</a></span>Postprocess_AddMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_AddMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a879168a4cc481955fb3c769ecc3dec86">AMFMetaDataArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pMetadataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> &amp;&#160;</td>
          <td class="paramname"><em>pSceneNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if child elements of node element is metadata and add it to scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMetadataList</td><td>- reference to list with collected metadata. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSceneNode</td><td>- scene node in which metadata will be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20be498c328b4665a5abe0e4088b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20be498c328b4665a5abe0e4088b840">&#9670;&nbsp;</a></span>Postprocess_BuildConstellation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_BuildConstellation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_m_f_constellation.html">AMFConstellation</a> &amp;&#160;</td>
          <td class="paramname"><em>pConstellation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#a4211f7976525bf3ce722a4190d4dc0b0">NodeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and add to <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a>'s list new part of scene graph defined by &lt;constellation&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pConstellation</td><td>- reference to &lt;constellation&gt; node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeArray</td><td>- reference to <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a>'s list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7a0a22a7fad58a1704dbaba4c2b832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7a0a22a7fad58a1704dbaba4c2b832">&#9670;&nbsp;</a></span>Postprocess_BuildMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_BuildMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_m_f_material.html">AMFMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>pMaterial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert material from <a class="el" href="struct_c_a_m_f_importer___node_element___material.html">CAMFImporter_NodeElement_Material</a> to <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMaterial</td><td>- source <a class="el" href="struct_c_a_m_f_importer___node_element___material.html" title="Structure that define material node.">CAMFImporter_NodeElement_Material</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae47b45b92b3872bae9b8c03abae2df90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47b45b92b3872bae9b8c03abae2df90">&#9670;&nbsp;</a></span>Postprocess_BuildMeshSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_BuildMeshSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_m_f_mesh.html">AMFMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>pNodeElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="vector3_8h.html#af90f71b9e287bdc258b1dd86656d8dfe">aiVector3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pVertexCoordinateArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_a_m_f_color.html">AMFColor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pVertexColorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_m_f_color.html">AMFColor</a> *&#160;</td>
          <td class="paramname"><em>pObjectColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">MeshArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pMeshList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> &amp;&#160;</td>
          <td class="paramname"><em>pSceneNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mesh for every &lt;volume&gt; in &lt;mesh&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodeElement</td><td>- reference to node element which kept &lt;mesh&gt; data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVertexCoordinateArray</td><td>- reference to vertices coordinates for all &lt;volume&gt;'s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVertexColorArray</td><td>- reference to vertices colors for all &lt;volume&gt;'s. If color for vertex is not set then corresponding member of array contain nullptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObjectColor</td><td>- pointer to colors for &lt;object&gt;. If color is not set then argument contain nullptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMaterialList</td><td>- reference to a list with defined materials. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMeshList</td><td>- reference to a list with all <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a> of the scene. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSceneNode</td><td>- reference to <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a> which will own new <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a>'s. </td></tr>
  </table>
  </dd>
</dl>
<p>TODO: clean unused vertices. "* 2": in certain cases - mesh full of triangle colors - vert_arr will contain duplicated vertices for colored triangles and initial vertices (for colored vertices) which in real became unused. This part need more thinking about optimization.</p>

</div>
</div>
<a id="a85a7b2af896f562a53b6aa3a56015d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a7b2af896f562a53b6aa3a56015d1d">&#9670;&nbsp;</a></span>Postprocess_BuildNodeAndObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_BuildNodeAndObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_m_f_object.html">AMFObject</a> &amp;&#160;</td>
          <td class="paramname"><em>pNodeElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_a_m_f_importer.html#ac04a2e9feccd56ee71a812febac3d4ab">MeshArray</a> &amp;&#160;</td>
          <td class="paramname"><em>meshList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> **&#160;</td>
          <td class="paramname"><em>pSceneNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To create <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a> and <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a> for it from &lt;object&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodeElement</td><td>- reference to node element which kept &lt;object&gt; data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshList</td><td>- reference to a list with all <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a> of the scene. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSceneNode</td><td>- pointer to place where new <a class="el" href="structai_node.html" title="A node in the imported hierarchy.">aiNode</a> will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32158ec90fd685d0f7b4a816c49fe427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32158ec90fd685d0f7b4a816c49fe427">&#9670;&nbsp;</a></span>Postprocess_BuildScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Postprocess_BuildScene </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> scene graph in <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> from collected data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pScene</td><td>- pointer to <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> where tree will be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dc2e39957e2021aa50c16ff8014cc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc2e39957e2021aa50c16ff8014cc3e">&#9670;&nbsp;</a></span>PostprocessHelper_CreateMeshDataArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::PostprocessHelper_CreateMeshDataArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_m_f_mesh.html">AMFMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>pNodeElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="vector3_8h.html#af90f71b9e287bdc258b1dd86656d8dfe">aiVector3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pVertexCoordinateArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_a_m_f_color.html">AMFColor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pVertexColorArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get data stored in &lt;vertices&gt; and place it to arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodeElement</td><td>- reference to node element which kept &lt;object&gt; data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVertexCoordinateArray</td><td>- reference to vertices coordinates kept in &lt;vertices&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pVertexColorArray</td><td>- reference to vertices colors for all &lt;vertex's. If color for vertex is not set then corresponding member of array contain nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9891e1102887b77581ea1b6cd3bb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9891e1102887b77581ea1b6cd3bb374">&#9670;&nbsp;</a></span>PostprocessHelper_GetTextureID_Or_Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Assimp::AMFImporter::PostprocessHelper_GetTextureID_Or_Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return converted texture ID which related to specified source textures ID's. </p>
<p>If converted texture does not exist then it will be created and ID on new converted texture will be returned. Conversion: set of textures from CAMFImporter_NodeElement_Texture to one <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___texture.html">SPP_Texture</a> and place it to converted textures list. Any of source ID's can be absent(empty string) or even one ID only specified. But at least one ID must be specified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pID_R</td><td>- ID of source "red" texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pID_G</td><td>- ID of source "green" texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pID_B</td><td>- ID of source "blue" texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pID_A</td><td>- ID of source "alpha" texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the texture in array of the converted textures. </dd></dl>

</div>
</div>
<a id="a435fadd3d6f5b78ff2ef9ee3d1914157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435fadd3d6f5b78ff2ef9ee3d1914157">&#9670;&nbsp;</a></span>PostprocessHelper_SplitFacesByTextureID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::PostprocessHelper_SplitFacesByTextureID </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html">SComplexFace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pInputList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::list&lt; <a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_complex_face.html">SComplexFace</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pOutputList_Separated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separate input list by texture IDs. </p>
<p>This step is needed because <a class="el" href="structai_mesh.html" title="enum aiMorphingMethod">aiMesh</a> can contain mesh which is use only one texture (or set: diffuse, bump etc). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pInputList</td><td>- input list with faces. Some of them can contain color or texture mapping, or both of them, or nothing. Will be cleared after processing. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutputList_Separated</td><td>- output list of the faces lists. Separated faces list by used texture IDs. Will be cleared before processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a047f06945fa656ebedde67819945b28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047f06945fa656ebedde67819945b28c">&#9670;&nbsp;</a></span>ReadFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structai_scene.html">aiScene</a> * BaseImporter::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_importer.html">Importer</a> *&#160;</td>
          <td class="paramname"><em>pImp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imports the given file and returns the imported data. </p>
<p>If the import succeeds, ownership of the data is transferred to the caller. If the import fails, nullptr is returned. The function takes care that any partially constructed data is destroyed beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td><a class="el" href="class_assimp_1_1_base_importer.html#ad2d8744585dcb094644b1caed04ac9ed">Importer</a> object hosting this loader. </td></tr>
    <tr><td class="paramname">pFile</td><td>Path of the file to be imported. </td></tr>
    <tr><td class="paramname">pIOHandler</td><td>IO-Handler used to open this and possible other files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imported data or nullptr if failed. If it failed a human-readable error description can be retrieved by calling <a class="el" href="class_assimp_1_1_base_importer.html#a15c379ec3a8399551d7b379de7fc3bc1" title="Returns the error description of the last error that occurred.">GetErrorText()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not intended to be overridden. Implement <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a3c0559661295085fc31d3c2b9f6a3eb9" title="Imports the given file into the given scene structure.">InternReadFile()</a> to do the import. If an exception is thrown somewhere in <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a3c0559661295085fc31d3c2b9f6a3eb9" title="Imports the given file into the given scene structure.">InternReadFile()</a>, this function will catch it and transform it into a suitable response to the caller. </dd></dl>

</div>
</div>
<a id="a6caed29cb9fa2d1e0aa0da2a17851ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caed29cb9fa2d1e0aa0da2a17851ca2">&#9670;&nbsp;</a></span>SearchFileHeaderForToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BaseImporter::SearchFileHeaderForToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>tokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numTokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>searchBytes</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tokensSol</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noAlphaBeforeTokens</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility for <a class="el" href="class_assimp_1_1_a_m_f_importer.html#a85a2e04a7d988def5ddc00c2f65532f7" title="Returns whether the class can handle the format of the given file.">CanRead()</a>. </p>
<p>The function searches the header of a file for a specific token and returns true if this token is found. This works for text files only. There is a rudimentary handling of UNICODE files. The comparison is case independent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIOSystem</td><td>IO System to work with </td></tr>
    <tr><td class="paramname">file</td><td>File name of the file </td></tr>
    <tr><td class="paramname">tokens</td><td>List of tokens to search for </td></tr>
    <tr><td class="paramname">numTokens</td><td>Size of the token array </td></tr>
    <tr><td class="paramname">searchBytes</td><td>Number of bytes to be searched for the tokens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c5e10c82316e3afd685732e8f734f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5e10c82316e3afd685732e8f734f87">&#9670;&nbsp;</a></span>SetApplicationUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Assimp::BaseImporter::SetApplicationUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8faf1d4f1475e98f96f95fa46aad44c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf1d4f1475e98f96f95fa46aad44c1">&#9670;&nbsp;</a></span>SetFileScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Assimp::BaseImporter::SetFileScale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will be called only by scale process when scaling is requested. </p>

</div>
</div>
<a id="a2ecaa6b808b2b282cb6aa321970a2ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecaa6b808b2b282cb6aa321970a2ad3">&#9670;&nbsp;</a></span>SetupProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseImporter::SetupProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_importer.html">Importer</a> *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called prior to <a class="el" href="class_assimp_1_1_base_importer.html#a047f06945fa656ebedde67819945b28c" title="Imports the given file and returns the imported data.">ReadFile()</a>. </p>
<p>The function is a request to the importer to update its configuration basing on the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a>'s configuration property list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td><a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_assimp_1_1_collada_loader.html#ac14e7fd3a8c13d5a209ff195afaf1b6e">Assimp::ColladaLoader</a>, <a class="el" href="class_assimp_1_1_unreal_importer.html#a6245271b643c4beac61819f6cb6291e2">Assimp::UnrealImporter</a>, <a class="el" href="class_assimp_1_1_terragen_importer.html#aa625c98a68fa8a2adb3b8c40074057a0">Assimp::TerragenImporter</a>, <a class="el" href="class_assimp_1_1_s_m_d_importer.html#a816bd8aeb3f5c8b932be1fd0d7d68798">Assimp::SMDImporter</a>, <a class="el" href="class_assimp_1_1_open_g_e_x_1_1_open_g_e_x_importer.html#adaab700f0b2e0e0575af63fe7ea2a633">Assimp::OpenGEX::OpenGEXImporter</a>, <a class="el" href="class_assimp_1_1_ogre_1_1_ogre_importer.html#a766a089f91a75d1c32fcdf2f21e0d464">Assimp::Ogre::OgreImporter</a>, <a class="el" href="class_assimp_1_1_n_d_o_importer.html#aae923695dd5a9ec9813fff4083562169">Assimp::NDOImporter</a>, <a class="el" href="class_assimp_1_1_m_d_l_importer.html#a0815608887ab4132a1bac328007c4572">Assimp::MDLImporter</a>, <a class="el" href="class_assimp_1_1_m_d_c_importer.html#ae95d077ab7d3da0740d96861649a75c7">Assimp::MDCImporter</a>, <a class="el" href="class_assimp_1_1_m_d5_importer.html#a53497bd13f6c050fb668554c8b4faa02">Assimp::MD5Importer</a>, <a class="el" href="class_assimp_1_1_m_d3_importer.html#a6e949a276c71016d1d5926ff76f13a86">Assimp::MD3Importer</a>, <a class="el" href="class_assimp_1_1_m_d2_importer.html#a21b5689b4e166cc89152f9bcf0bd2418">Assimp::MD2Importer</a>, <a class="el" href="class_assimp_1_1_l_w_s_importer.html#ad3192a55e03c2660835d8f5d790014e6">Assimp::LWSImporter</a>, <a class="el" href="class_assimp_1_1_l_w_o_importer.html#a9c930022ee8c5d9816f4cdab0b747195">Assimp::LWOImporter</a>, <a class="el" href="class_assimp_1_1_i_r_r_importer.html#af7f79b288d02fba72959b34f547e1766">Assimp::IRRImporter</a>, <a class="el" href="class_assimp_1_1_i_f_c_importer.html#ad1e3ea4947b7f534975b060bf66aad33">Assimp::IFCImporter</a>, <a class="el" href="class_assimp_1_1_f_b_x_importer.html#aa0b027a6c4fe87c01dc43cacd2f17116">Assimp::FBXImporter</a>, <a class="el" href="class_assimp_1_1_c_s_m_importer.html#a086615f1f4d3496acdd96be7fa32a90e">Assimp::CSMImporter</a>, <a class="el" href="class_assimp_1_1_c_o_b_importer.html#ad644da920e9f44f852f1c0e295164952">Assimp::COBImporter</a>, <a class="el" href="class_assimp_1_1_c4_d_importer.html#a7d3f9a0f07c9b526c4ac9a6233e97c70">Assimp::C4DImporter</a>, <a class="el" href="class_assimp_1_1_b_v_h_loader.html#a8efcc5b879f1d5595feb1c3d505fa536">Assimp::BVHLoader</a>, <a class="el" href="class_assimp_1_1_blender_importer.html#a4c8b1b1c9b79bed2c2a56d56c8060889">Assimp::BlenderImporter</a>, <a class="el" href="class_assimp_1_1_a_s_e_importer.html#a71d33277500d8b4c300e2b36eb94d472">Assimp::ASEImporter</a>, <a class="el" href="class_assimp_1_1_a_c3_d_importer.html#a59bf78ed30aa9de6e16d6ecfe5b3d1ad">Assimp::AC3DImporter</a>, <a class="el" href="class_assimp_1_1_d3_m_f_importer.html#a43c291005c9886df20d86e10e8e8610f">Assimp::D3MFImporter</a>, and <a class="el" href="class_assimp_1_1_discreet3_d_s_importer.html#a69c8d30c01af9ac1548a9fcb25ab28ed">Assimp::Discreet3DSImporter</a>.</p>

</div>
</div>
<a id="a2de9d21d35c9060480142dc536ce5352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de9d21d35c9060480142dc536ce5352">&#9670;&nbsp;</a></span>SimpleExtensionCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BaseImporter::SimpleExtensionCheck </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext2</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a file has a specific file extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Input file </td></tr>
    <tr><td class="paramname">ext0</td><td>Extension to check for. Lowercase characters only, no dot! </td></tr>
    <tr><td class="paramname">ext1</td><td>Optional second extension </td></tr>
    <tr><td class="paramname">ext2</td><td>Optional third extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Case-insensitive </dd></dl>

</div>
</div>
<a id="a1c43dc005eb52d2902d13f1a475ec9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c43dc005eb52d2902d13f1a475ec9cd">&#9670;&nbsp;</a></span>TextFileToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseImporter::TextFileToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_stream.html">IOStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7">TextFileMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_assimp_1_1_base_importer.html#a9fe6b47937a7c897536cac1513b65eb7ae507341521279743797bdce9f7a21081">FORBID_EMPTY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for text file loaders which copies the contents of the file into a memory buffer and converts it to our UTF8 representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Stream to read from. </td></tr>
    <tr><td class="paramname">data</td><td>Output buffer to be resized and filled with the converted text file data. The buffer is terminated with a binary 0. </td></tr>
    <tr><td class="paramname">mode</td><td>Whether it is OK to load empty text files. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94970abc42b694396afb300a45ffeb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94970abc42b694396afb300a45ffeb73">&#9670;&nbsp;</a></span>Throw_CloseNotFound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Throw_CloseNotFound </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c4f7d3bbc6de78b05aa851a96d209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c4f7d3bbc6de78b05aa851a96d209b">&#9670;&nbsp;</a></span>Throw_ID_NotFound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Throw_ID_NotFound </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd0c2aa30037c715abc4b9f161bc0f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0c2aa30037c715abc4b9f161bc0f97">&#9670;&nbsp;</a></span>Throw_IncorrectAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Throw_IncorrectAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pAttrName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79bcbbc4cb2a41522eb51435e2b2da3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bcbbc4cb2a41522eb51435e2b2da3b">&#9670;&nbsp;</a></span>Throw_IncorrectAttrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Throw_IncorrectAttrValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pAttrName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a52e0c498a0e2fea1cdf31a08d8a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a52e0c498a0e2fea1cdf31a08d8a7d1">&#9670;&nbsp;</a></span>Throw_MoreThanOnceDefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::Throw_MoreThanOnceDefined </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pNodeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pDescription</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d1ad05fde79c32af5af694f976657a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ad05fde79c32af5af694f976657a7">&#9670;&nbsp;</a></span>UpdateImporterScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BaseImporter::UpdateImporterScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_importer.html">Importer</a> *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a393394ef52250e7ce09ef77455192684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393394ef52250e7ce09ef77455192684">&#9670;&nbsp;</a></span>XML_CheckNode_MustHaveChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::AMFImporter::XML_CheckNode_MustHaveChildren </td>
          <td>(</td>
          <td class="paramtype">pugi::xml_node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c57be60be98d108cabd6a784cf9aae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c57be60be98d108cabd6a784cf9aae4">&#9670;&nbsp;</a></span>XML_SearchNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::AMFImporter::XML_SearchNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a15fb4512ad41a241a3b8de3fa63c0434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fb4512ad41a241a3b8de3fa63c0434">&#9670;&nbsp;</a></span>applicationUnits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a> Assimp::BaseImporter::applicationUnits = ImporterUnits::M</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d7f6f7a8971bfcc30dc327daf8e03f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f6f7a8971bfcc30dc327daf8e03f5">&#9670;&nbsp;</a></span>Description</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a> Assimp::AMFImporter::Description</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;Additive manufacturing file format(AMF) Importer&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;smalcom&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;See documentation in source code. Chapter: Limitations.&quot;</span>,</div>
<div class="line">    <a class="code" href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449a022e8627161639e2362da3ca7fff2c01">aiImporterFlags_SupportTextFlavour</a> | <a class="code" href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449a6344b2d4487c5894e20cf06e807e127f">aiImporterFlags_LimitedSupport</a> | <a class="code" href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449aff5af9356317719908b4dee9b50588f3">aiImporterFlags_Experimental</a>,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    0,</div>
<div class="line">    <span class="stringliteral">&quot;amf&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aimporterdesc_8h_html_a3c78e1208ecbd75fecdbb4e38d820449a022e8627161639e2362da3ca7fff2c01"><div class="ttname"><a href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449a022e8627161639e2362da3ca7fff2c01">aiImporterFlags_SupportTextFlavour</a></div><div class="ttdeci">@ aiImporterFlags_SupportTextFlavour</div><div class="ttdoc">Indicates that there is a textual encoding of the file format; and that it is supported.</div><div class="ttdef"><b>Definition:</b> importerdesc.h:64</div></div>
<div class="ttc" id="aimporterdesc_8h_html_a3c78e1208ecbd75fecdbb4e38d820449a6344b2d4487c5894e20cf06e807e127f"><div class="ttname"><a href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449a6344b2d4487c5894e20cf06e807e127f">aiImporterFlags_LimitedSupport</a></div><div class="ttdeci">@ aiImporterFlags_LimitedSupport</div><div class="ttdoc">Indicates that the importer reads only a very particular subset of the file format.</div><div class="ttdef"><b>Definition:</b> importerdesc.h:78</div></div>
<div class="ttc" id="aimporterdesc_8h_html_a3c78e1208ecbd75fecdbb4e38d820449aff5af9356317719908b4dee9b50588f3"><div class="ttname"><a href="importerdesc_8h.html#a3c78e1208ecbd75fecdbb4e38d820449aff5af9356317719908b4dee9b50588f3">aiImporterFlags_Experimental</a></div><div class="ttdeci">@ aiImporterFlags_Experimental</div><div class="ttdoc">Indicates that the importer is highly experimental and should be used with care.</div><div class="ttdef"><b>Definition:</b> importerdesc.h:84</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af85971f80c5f45fef8c3a3395e4bbe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85971f80c5f45fef8c3a3395e4bbe14">&#9670;&nbsp;</a></span>fileScale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Assimp::BaseImporter::fileScale = 1.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5bb9d0bff964c79b625c754b3adb04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bb9d0bff964c79b625c754b3adb04c">&#9670;&nbsp;</a></span>importerScale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Assimp::BaseImporter::importerScale = 1.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac43f3495d597a22da47ea894f5432016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43f3495d597a22da47ea894f5432016">&#9670;&nbsp;</a></span>importerUnits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_assimp_1_1_base_importer.html#a6b225ea9aa92433ec03cb41492a0d451">ImporterUnits</a>, double&gt; Assimp::BaseImporter::importerUnits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_assimp.html" title="Helper structures for the Collada loader.">Assimp</a> <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> unit conversions available NOTE: Valid options are initialised in the constructor in the implementation file to work around a VS2013 compiler bug if support for that compiler is dropped in the future initialisation can be moved back here. </p>

</div>
</div>
<a id="abd2c9b86479c0c165e5d84d733e53373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2c9b86479c0c165e5d84d733e53373">&#9670;&nbsp;</a></span>m_ErrorText</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Assimp::BaseImporter::m_ErrorText</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error description in case there was one. </p>

</div>
</div>
<a id="a7bf84fb733992558272add378e7d9525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf84fb733992558272add378e7d9525">&#9670;&nbsp;</a></span>m_Exception</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr Assimp::BaseImporter::m_Exception</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The exception, in case there was one. </p>

</div>
</div>
<a id="aeb17ba9eee14fcdfe2c6f45bf940139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb17ba9eee14fcdfe2c6f45bf940139d">&#9670;&nbsp;</a></span>m_progress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a>* Assimp::BaseImporter::m_progress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Currently set progress handler. </p>

</div>
</div>
<a id="ae11f52d00bc07e633983ffe7c1beea22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11f52d00bc07e633983ffe7c1beea22">&#9670;&nbsp;</a></span>mMaterial_Converted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___material.html">SPP_Material</a>&gt; Assimp::AMFImporter::mMaterial_Converted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of converted materials for postprocessing step. </p>

</div>
</div>
<a id="aef7de0482677984a39d79dce565758a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7de0482677984a39d79dce565758a3">&#9670;&nbsp;</a></span>mNodeElement_Cur</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a>* Assimp::AMFImporter::mNodeElement_Cur</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current element. </p>

</div>
</div>
<a id="aea60ab11c46fbfb41ae5d2da2769443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea60ab11c46fbfb41ae5d2da2769443b">&#9670;&nbsp;</a></span>mNodeElement_List</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_a_m_f_node_element_base.html">AMFNodeElementBase</a> *&gt; Assimp::AMFImporter::mNodeElement_List</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All elements of scene graph. </p>

</div>
</div>
<a id="a21d9ceefd78646dad36a9cf6f7ed036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d9ceefd78646dad36a9cf6f7ed036f">&#9670;&nbsp;</a></span>mTexture_Converted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="struct_assimp_1_1_a_m_f_importer_1_1_s_p_p___texture.html">SPP_Texture</a>&gt; Assimp::AMFImporter::mTexture_Converted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of converted textures for postprocessing step. </p>

</div>
</div>
<a id="a328ba05ba9b5ed06ddaaf955464dc210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328ba05ba9b5ed06ddaaf955464dc210">&#9670;&nbsp;</a></span>mUnit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Assimp::AMFImporter::mUnit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1c45f2ccb689ac83a49f465efbcc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c45f2ccb689ac83a49f465efbcc21">&#9670;&nbsp;</a></span>mVersion</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Assimp::AMFImporter::mVersion</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba4b0a07092f973a8f9c1c10663d6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba4b0a07092f973a8f9c1c10663d6f0">&#9670;&nbsp;</a></span>mXmlParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_assimp.html#a6295df0173c66269feae004611f499a2">XmlParser</a>* Assimp::AMFImporter::mXmlParser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_a_m_f_importer_8hpp.html">AMFImporter.hpp</a></li>
<li><a class="el" href="_a_m_f_importer_8cpp.html">AMFImporter.cpp</a></li>
<li><a class="el" href="_a_m_f_importer___geometry_8cpp.html">AMFImporter_Geometry.cpp</a></li>
<li><a class="el" href="_a_m_f_importer___material_8cpp.html">AMFImporter_Material.cpp</a></li>
<li><a class="el" href="_a_m_f_importer___postprocess_8cpp.html">AMFImporter_Postprocess.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 22 2021 22:29:54 for Assimp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
